/**
@file CCondition.h

En este fichero se define la interfaz para las condiciones
de las aristas de las máquinas de estado, así como cuatro 
condiciones de ejemplo: CConditionTrue (una condición que 
siempre se evalúa como verdadera), CConditionFinished (es 
verdadera si la acción asociada al nodo ha terminado), 
CConditionSuccess (es  verdadera si la acción asociada al 
nodo ha terminado con éxito) y CConditionFail (es verdadera 
si la acción asociada al nodo ha terminado con fallo).

@author Gonzalo Flórez
@date Diciembre 2010

*/

#pragma once

#ifndef __AI_Condition_H
#define __AI_Condition_H

#include "BaseSubsystems\Math.h"
#include "LatentAction.h"

namespace Logic
{
	class Logic::CEntity;
};

namespace AI 
{
	/**
	Interfaz que deberán implementar las condiciones de 
	las máquinas de estado.
	*/
	template <class TNode>
	class ICondition
	{
	public:

		virtual ~ICondition(){}
		/**
		En este método se comprobará la condición. Recibe el 
		nodo al que pertenece la condición (de esta manera 
		podemos comprobar si el nodo ha terminado y en qué 
		condiciones) y la entidad que ejecuta el comportamiento 
		(que puede ser NULL).
		
		@param currentNode Nodo al que pertenece la condición.
		@param entity Entidad que ejecuta el comportamiento
		@return true o false según si se cumple la condición o no.
		*/
		virtual bool check(TNode* currentNode, Logic::CEntity* entity) = 0;
		/**
		Devuelve true si a la acción le interesa el tipo de mensaje
		enviado como parámetro.
		@param msg Mensaje que ha recibido la entidad.
		@return true Si la acción está en principio interesada
		por ese mensaje.
		*/
		virtual bool acceptN(const std::shared_ptr<NMessage> &message) {return false;};
		/**
		Procesa el mensaje recibido. El método es invocado durante la
		ejecución de la acción cuando se recibe el mensaje.

		@param msg Mensaje recibido.
		*/
		virtual void processN(const std::shared_ptr<NMessage> &message) {};
	}; // class CCondition

	/**
	Esta clase define una condición que siempre se evalúa a true.
	*/
	template <class TNode>
	class CConditionTrue : public ICondition<TNode>
	{
	public:
		bool check(TNode* currentNode, Logic::CEntity* entity) { return true; }
	};
	
	/**
	Esta clase define una condición que se evalúa a true si la 
	acción a la que pertenece ha terminado.
	*/
	class CConditionFinished : public ICondition<CLatentAction>
	{
	public:
		bool check(CLatentAction* currentNode, Logic::CEntity* entity) 
		{
			// Comprobar si el estado del nodo que se está ejecutando es terminado
			return currentNode->getStatus() == CLatentAction::LAStatus::SUCCESS || 
				currentNode->getStatus() == CLatentAction::LAStatus::FAIL;

		}
	};

	/**
	Esta clase define una condición que se evalúa a true si la 
	acción a la que pertenece ha terminado con éxito.
	*/
	class CConditionSuccess : public ICondition<CLatentAction>
	{
	public:
		bool check(CLatentAction* currentNode, Logic::CEntity* entity) 
		{ 
			// Comprobar si el estado del nodo que se está ejecutando es éxito
			return currentNode->getStatus() == CLatentAction::LAStatus::SUCCESS;
		}
	};

	/**
	Esta clase define una condición que se evalúa a true si la 
	acción a la que pertenece ha terminado con fallo.
	*/
	class CConditionFail : public ICondition<CLatentAction>
	{
	public:
		bool check(CLatentAction* currentNode, Logic::CEntity* entity) 
		{ 
			// Comprobar si el estado del nodo que se está ejecutando es fallo
			return currentNode->getStatus() == CLatentAction::LAStatus::FAIL;
		}
	};

	/**
	Esta clase define una condición que devuelve true 
	si se recibió un mensaje de un tipo concreto en el último tick
	*/
	template <class TNode>
	class CConditionMessage : public ICondition<TNode>
	{
	public:
		/**
		En el constructor recibimos el tipo de mensaje que 
		hará saltar la condición
		@param messageType Tipo de mensaje que estamos escuchando
		*/
		CConditionMessage(std::string messageType) : _received(false) {
			_messageType = messageType;
		}			

		/**
		En el check sólo tenemos que comprobar el flag _received. Este flag
		se habrá activado en process si durante este tick hemos recibido
		un mensaje del tipo adecuado.
		Una vez hecha la comprobación, reseteamos el flag a false.
		@param currentNode Nodo al que pertenece la condición (no se usa)
		@param entity Entidad que ejecuta el comportamiento (no se usa)
		@return true o false según si se cumple la condición o no.

		*/
		bool check(TNode* currentNode, Logic::CEntity* entity) { 
			// Tenemos que comprobar el flag _received y luego actualizarlo
			// de nuevo a false para el siguiente tick
			if (_received)
			{
				_received = false;
				return true;
			}
			return false;
		}
		/**
		Devuelve true si el tipo del mensaje recibido coincide con el 
		que estamos esperando
		@param msg Mensaje que ha recibido la entidad.
		@return true Si la acción está en principio interesada
		por ese mensaje.
		*/
		virtual bool acceptN(const std::shared_ptr<NMessage> &message) {
			// La condición debe aceptar mensajes del tipo indicado en _messageType
			return (message->type.compare(_messageType) == 0);
		};
		/**
		Procesa el mensaje recibido. Como sólo aceptamos mensajes del
		tipo en el que estamos interesados aquí directamente ponemos 
		el flag a true.

		@param msg Mensaje recibido.
		*/
		virtual void processN(const std::shared_ptr<NMessage> &message) {
			// Actualizamos el flag _received si el mensaje es del tipo _messageType			
			_received = true;
		};

	private:
		/** Flag que se activa cuando recibimos un mensaje del tipo en el que estamos interesados */
		bool _received;
		/** Tipo del mensaje que esperamos */
		std::string _messageType;
	};


	/**
	Esta clase define una condición que se evalúa a true si la 
	entidad se encuentra en la posición indicada, con una tolerancia
	*/
	template <class TNode>
	class CConditionNear : public ICondition<TNode>
	{
	public:
		CConditionNear(Vector3 position, float tolerance) : _position(position), _tolerance(tolerance) {}

		bool check(CLatentAction* currentNode, Logic::CEntity* entity) 
		{ 
			// Tiene que devolver true cuando la posición de la entidad sea
			// igual a la posición que ha recibido como parámetro (con la tolerancia)				
			return entity->getPosition().positionCloses(_position);
		}

	protected:
		Vector3 _position;
		float _tolerance;
	};

} // namespace AI 

#endif // __AI_Condition_H
